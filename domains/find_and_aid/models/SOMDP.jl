using Combinatorics
using Statistics
import Base.==

include("MDP.jl")
include(joinpath(@__DIR__, "..", "..", "..", "solvers", "VIMDPSolver.jl"))
include(joinpath(@__DIR__, "..", "..", "..", "solvers", "LAOStarSolver.jl"))

function index(element, collection)
    for i=1:length(collection)
        if collection[i] == element
            return i
        end
    end
    return -1
end

struct MemoryState
    state::DomainState
    action_list::Vector{DomainAction}
end

function ==(s‚ÇÅ::MemoryState, s‚ÇÇ::MemoryState)
    return (s‚ÇÅ.state == s‚ÇÇ.state && s‚ÇÅ.action_list == s‚ÇÇ.action_list)
end

struct MemoryAction
    value::Union{String,Char}
end

struct SOMDP
    M::MDP
    S::Vector{MemoryState}
    A::Vector{MemoryAction}
    T::Function
    R::Function
   s‚ÇÄ::MemoryState
    œÑ::Dict{Int, Dict{Int, Dict{Int, Float64}}}
    Œ¥::Integer
    H::Function
end

function generate_states(M::MDP, Œ¥::Integer)
    A = M.A

    S = Vector{MemoryState}()
    G = Vector{MemoryState}()
    s‚ÇÄ = -1
    for depth in 0:Œ¥
        for (i, state) in enumerate(M.S)
            if depth == 0
                s = MemoryState(state, Vector{DomainAction}())
                push!(S, s)
                if state in M.G
                    push!(G, s)
                end
                if state == M.s‚ÇÄ
                    s‚ÇÄ = length(S)
                end
            else
                for action_list ‚àà collect(Base.product(ntuple(i->A, depth)...))
                    s = MemoryState(state, [a for a ‚àà action_list])
                    push!(S, s)
                end
            end
        end
    end
    return S, S[s‚ÇÄ], G
end

function generate_actions(M::MDP)
    A = [MemoryAction(a.value) for a in M.A]
    push!(A, MemoryAction("QUERY"))
    return A
end

function eta(state::MemoryState,
            action::MemoryAction)
    return 0.3 * state.‚Ñí
end

function recurse_transition(‚Ñ≥::SOMDP,
                         state::MemoryState,
                        action::MemoryAction,
                        state‚Ä≤::MemoryState)::Float64
    s, a, s‚Ä≤ = index(state, ‚Ñ≥.S), index(action, ‚Ñ≥.A), index(state‚Ä≤, ‚Ñ≥.S)
    if isempty(state.action_list)
        return ‚Ñ≥.M.T[s][a][s‚Ä≤]
    end

    if s ‚àà keys(‚Ñ≥.œÑ)
        if a ‚àà keys(‚Ñ≥.œÑ[s])
            if s‚Ä≤ ‚àà keys(‚Ñ≥.œÑ[s][a])
                return ‚Ñ≥.œÑ[s][a][s‚Ä≤]
            end
        else
            ‚Ñ≥.œÑ[s][a] = Dict{Int, Float64}()
        end
    else
        ‚Ñ≥.œÑ[s] = Dict(a => Dict{Int, Float64}())
    end

    action‚Çö = MemoryAction(last(state.action_list).value)
    state‚Çö = MemoryState(state.state,
                         state.action_list[1:length(state.action_list)-1])
    p = 0.

    for bs=1:length(‚Ñ≥.M.S)
        q = ‚Ñ≥.M.T[bs][a][s‚Ä≤]
        if q ‚â† 0.
            p += q * recurse_transition(‚Ñ≥, state‚Çö, action‚Çö, ‚Ñ≥.S[bs])
        end
    end

    ‚Ñ≥.œÑ[s][a][s‚Ä≤] = p
    return p
end

function generate_transitions(‚Ñ≥::SOMDP,
                           state::MemoryState,
                          action::MemoryAction)
    M, S, A = ‚Ñ≥.M, ‚Ñ≥.S, ‚Ñ≥.A
    T = zeros(length(S))
    if isempty(state.action_list)
        s, a = index(state, S), index(action, A)
        if action.value == "QUERY"
            T[s] = 1.
            return T
        elseif maximum(M.T[s][a]) == 1.
            T[argmax(M.T[s][a])] = 1.
            return T
        else
            ms‚Ä≤ = length(M.S) + length(M.A) * (s-1) + a
            T[ms‚Ä≤] = eta(state, action)
            for (s‚Ä≤, state‚Ä≤) in enumerate(M.S)
                T[s‚Ä≤] = M.T[s][a][s‚Ä≤] * (1 - T[ms‚Ä≤])
            end
        end
    elseif action.value == "QUERY"
        action‚Çö = MemoryAction(last(state.action_list).value)
        state‚Çö = MemoryState(state.state,
                             state.action_list[1:length(state.action_list)-1])
        for s‚Ä≤ = 1:length(M.S)
            T[s‚Ä≤] = recurse_transition(‚Ñ≥, state‚Çö, action‚Çö, S[s‚Ä≤])
        end
    elseif length(state.action_list) == ‚Ñ≥.Œ¥
        T[length(M.S)] = 1.
    else
        action_list‚Ä≤ = copy(state.action_list)
        push!(action_list‚Ä≤, DomainAction(action.value))
        mstate‚Ä≤ = MemoryState(state.state, action_list‚Ä≤)
        T[index(mstate‚Ä≤, S)] = .75
        for s‚Ä≤ = 1:length(M.S)
            T[s‚Ä≤] = 0.25recurse_transition(‚Ñ≥, state, action, S[s‚Ä≤])
        end
    end
    return T
end

function generate_reward(‚Ñ≥::SOMDP,
                      state::MemoryState,
                     action::MemoryAction)
    M, S, A = ‚Ñ≥.M, ‚Ñ≥.S, ‚Ñ≥.A
    if action.value == "QUERY"
        return 3.  ## TODO: Adjust this cost somehow??
    elseif length(state.action_list) == 0
        return M.C[index(state, S)][index(action, A)]
    else
        a = index(action, A)
        action‚Çö = MemoryAction(last(state.action_list).value)
        state‚Çö = MemoryState(state.state,
                             state.action_list[1:length(state.action_list)-1])
        return (sum(M.C[bs][a] * recurse_transition(‚Ñ≥, state‚Çö, action‚Çö, S[bs])
                                                      for bs = 1:length(M.S)))
    end
end

function generate_heuristic(‚Ñ≥::SOMDP,
                             V::Vector{Float64},
                         state::MemoryState,
                        action::MemoryAction)
    M, S, A = ‚Ñ≥.M, ‚Ñ≥.S, ‚Ñ≥.A
    if length(state.action_list) == 0
        return V[index(state, S)]
    else
        action‚Çö = MemoryAction(last(state.action_list).value)
        state‚Çö = MemoryState(state.state,
                            state.action_list[1:length(state.action_list)-1])
        h = 0.0
        for bs = 1:length(M.S)
            v = V[bs]
            if v ‚â† 0.0
                h += v * recurse_transition(‚Ñ≥, state‚Çö, action‚Çö, S[bs])
            end
        end
        return h
        # return (sum(V[bs] * recurse_transition(‚Ñ≥, state‚Çö, action‚Çö, S[bs])
        #                                          for bs = 1:length(M.S)))
    end
    return 0.
end

function generate_successor(‚Ñ≥::SOMDP,
                         state::MemoryState,
                        action::MemoryAction)
    thresh = rand()
    p = 0.
    T = ‚Ñ≥.T(‚Ñ≥, s, a)
    for (s‚Ä≤, state‚Ä≤) ‚àà enumerate(‚Ñ≥.S)
        p += T[s‚Ä≤]
        if p >= thresh
            return state‚Ä≤
        end
    end
end

function simulate(‚Ñ≥::SOMDP,
                   ùí±::ValueIterationSolver)
    M, S, A, R, state = ‚Ñ≥.M, ‚Ñ≥.S, ‚Ñ≥.A, ‚Ñ≥.R, ‚Ñ≥.s‚ÇÄ
    true_state, G = M.s‚ÇÄ, M.G
    rewards = Vector{Float64}()
    for i = 1:100
        episode_reward = 0.0
        while true_state ‚àâ G
            if length(state.action_list) > 0
                cum_cost += 3
                state = MemoryState(true_state, Vector{CampusAction}())
            else
                s = index(state, S)
                true_s = index(true_state, M.S)
                a = ùí±.œÄ[true_s]
                action = M.A[a]
                memory_action = MemoryAction(action.value)
                cum_cost += M.C[true_s][a]
                state = generate_successor(‚Ñ≥, state, memory_action)
                if length(state.action_list) == 0
                    true_state = state.state
                else
                    true_state = generate_successor(M, true_s, a)
                end
            end
        end
    end
    println("Average cost to goal: $cum_cost")
end

# function simulate(‚Ñ≥::MemorySSP, ‚Ñí::LAOStarSolver, ùí±::ValueIterationSolver)
#     M, S, A, C = ‚Ñ≥.M, ‚Ñ≥.S, ‚Ñ≥.A, ‚Ñ≥.C
#     costs = Vector{Float64}()
#     # println("Expected cost to goal: $(‚Ñí.V[index(state, S)])")
#     for i=1:100
#         state, true_state, G = ‚Ñ≥.s‚ÇÄ, M.s‚ÇÄ, M.G
#         episode_cost = 0.0
#         while true_state ‚àâ G
#             s = index(state, S)
#             a, _ = solve(‚Ñí, ùí±, ‚Ñ≥, s)
#             action = A[a]
#             # println("Taking action $action in memory state $state in true state $true_state.")
#             if action.value == "query"
#                 state = MemoryState(true_state, Vector{CampusAction}())
#                 episode_cost += 3
#             else
#                 true_s = index(true_state, M.S)
#                 episode_cost += M.C[true_s][a]
#                 state = generate_successor(‚Ñ≥, state, A[a])
#                 if length(state.action_list) == 0
#                     true_state = state.state
#                 else
#                     true_state = generate_successor(M, true_s, a)
#                 end
#             end
#         end
#         push!(costs, episode_cost)
#         println("Episode $i           Total cumulative cost: $(mean(costs)) ‚®¶ $(std(costs))")
#     end
#     # println("Reached the goal.")
#     println("Total cumulative cost: $(mean(costs)) ‚®¶ $(std(costs))")
# end
#
# function simulate(‚Ñ≥::MemorySSP, ùí±::ValueIterationSolver, œÄ::MCTSSolver)
#     M, S, A, C = ‚Ñ≥.M, ‚Ñ≥.S, ‚Ñ≥.A, ‚Ñ≥.C
#     costs = Vector{Float64}()
#     # println("Expected cost to goal: $(‚Ñí.V[index(state, S)])")
#     for i=1:1
#         state, true_state, G = ‚Ñ≥.s‚ÇÄ, M.s‚ÇÄ, M.G
#         episode_cost = 0.0
#         while true_state ‚àâ G
#             # s = index(state, S)
#             # a, _ = solve(‚Ñí, ùí±, ‚Ñ≥, s)
#             action = solve(œÄ, state)
#             # action = A[a]
#             println("Taking action $action in memory state $state in true state $true_state.")
#             if action.value == "query"
#                 state = MemoryState(true_state, Vector{CampusAction}())
#                 episode_cost += 3
#             else
#                 true_s = index(true_state, M.S)
#                 a = index(action, A)
#                 episode_cost += M.C[true_s][a]
#                 state = generate_successor(‚Ñ≥, state, action)
#                 if length(state.action_list) == 0
#                     true_state = state.state
#                 else
#                     true_state = generate_successor(M, true_s, a)
#                 end
#             end
#         end
#         push!(costs, episode_cost)
#         println("Episode $i           Total cumulative cost: $(mean(costs)) ‚®¶ $(std(costs))")
#     end
#     # println("Reached the goal.")
#     println("Total cumulative cost: $(mean(costs)) ‚®¶ $(std(costs))")
# end

function build_model(M::MDP)
    Œ¥ = 1
    S, s‚ÇÄ = generate_states(M, Œ¥)
    A = generate_actions(M)
    œÑ = Dict{Int, Dict{Int, Dict{Int, Float64}}}()
    ‚Ñ≥ = MemorySSP(M, S, A, generate_transitions, generate_reward, s‚ÇÄ,
                   œÑ, Œ¥, generate_heuristic)
    return ‚Ñ≥, ùí±
end

function solve_model(‚Ñ≥, ùí±)
    # ‚Ñí = LAOStarSolver(100000, 1000., 1.0, .001, Dict{Integer, Integer}(),
    #      zeros(length(‚Ñ≥.S)), zeros(length(‚Ñ≥.S)),
    #      zeros(length(‚Ñ≥.S)), zeros(length(‚Ñ≥.A)))
    # ùí∞ = UCTSolver(zeros(length(‚Ñ≥.S)), Set(), 1000, 100, 0)
    U(state) = minimum(heuristic(‚Ñ≥, ùí±.V, state, action) for action in ‚Ñ≥.A)
    U(state, action) = heuristic(‚Ñ≥, ùí±.V, state, action)

    œÄ = MCTSSolver(‚Ñ≥, Dict(), Dict(), U, 10, 10000, 100.0)
    S, s = ‚Ñ≥.S, ‚Ñ≥.s‚ÇÄ
    # a, total_expanded = @time solve(‚Ñí, ùí±, ‚Ñ≥, index(s, S))
    # a = @time solve(ùí∞, ùí±, ‚Ñ≥, )
    a = @time solve(œÄ, s)
    return œÄ, a
    # println("LAO* expanded $total_expanded nodes.")
    # println("Expected cost to goal: $(‚Ñí.V[index(s,S)])")
    # return ‚Ñí, ‚Ñí.V[index(s, S)]
    # return ùí∞, ùí∞.V[index(s, S)]
end

function main()
    domain_map_file = joinpath(@__DIR__, "..", "maps", "collapse_1.txt")

    println("Starting...")
    M = build_model(domain_map_file)
    V = solve_model(M)

    ‚Ñ≥, ùí± = @time build_model(M)
    # simulate(‚Ñ≥, ùí±)
    println("Solving...")
    println(length(‚Ñ≥.S))
    # ‚Ñí, expected_cost = solve_model(‚Ñ≥, ùí±)
    # ùí∞, expected_cost = solve_model(‚Ñ≥, ùí±)
    œÄ, a = solve_model(‚Ñ≥, ùí±)
    expected_cost = œÄ.Q[(‚Ñ≥.s‚ÇÄ, a)]
    println("Expected cost from initial state: $expected_cost")
    println("Simulating...")
    # simulate(‚Ñ≥, ‚Ñí, ùí±)
    simulate(‚Ñ≥, ùí±, œÄ)
end

main()
